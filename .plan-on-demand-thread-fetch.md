# On-Demand Slack Thread Fetch

## Overview
Enable on-demand fetching of Slack threads from the Slack API when users click "View thread" on threads that haven't been mirrored yet.

## Current Problem
When clicking "View thread" on an unmirrored thread:
- Backend: Returns error "thread file not found for channel X and ts Y"
- Frontend: Shows error message to user
- Result: Thread data never retrieved, poor UX

## Solution
Fetch missing threads from Slack API on-demand:
1. Backend checks mirror for thread file
2. If missing AND slack token available → fetch from Slack API, save to mirror, return data
3. If missing AND no token → return helpful error message
4. Frontend always triggers fetch when thread clicked (remove isComplete blocking)

## Implementation Plan

### Backend Changes

#### 1. Add Slack Token to AppState
**File**: `crates/dashboard_api/src/lib.rs`
- Add `slack_token: Option<Arc<String>>` field to `AppState` struct
- In `run_dashboard_server`: read `VIBEOS_SLACK_TOKEN` env var
- Store in AppState for use in handlers

#### 2. Add Dependency
**File**: `crates/dashboard_api/Cargo.toml`
- Add `vibeos_cli` as dependency to access `SlackClient`

#### 3. Create Fetch & Save Function
**File**: `crates/dashboard_api/src/lib.rs`

```rust
async fn fetch_and_save_slack_thread(
    slack_token: &str,
    slack_mirror_dir: &Path,
    channel_id: &str,
    thread_ts: &str,
) -> Result<Vec<EventEnvelope>>
```

Logic:
- Create `SlackClient` with token
- Call `fetch_thread_replies_since(channel_id, thread_ts, None)`
- Format filename: `{channel_id}_{thread_ts_with_underscores}.jsonl`
- Write messages to `slack_mirror/threads/{filename}`
- Use `SlackAdapter` to read back as `EventEnvelope`s
- Add logging at each step

#### 4. Modify Handler
**File**: `crates/dashboard_api/src/lib.rs` → `get_slack_thread`

Current: `adapter.load_thread()` → if error, bail
New:
```rust
let mut events = match adapter.load_thread(&channel_id, &thread_ts) {
    Ok(events) => {
        info!("Loaded {} messages from mirror", events.len());
        events
    }
    Err(_) if state.slack_token.is_some() => {
        info!("Thread not in mirror, fetching from Slack API...");
        fetch_and_save_slack_thread(
            state.slack_token.as_ref().unwrap(),
            &state.slack_mirror_dir,
            &channel_id,
            &thread_ts
        ).await?
    }
    Err(e) => {
        warn!("Thread not found and no Slack token configured");
        return Err(AppError(anyhow!("Thread not in mirror and VIBEOS_SLACK_TOKEN not set: {}", e)));
    }
};
```

### Frontend Changes

#### 5. Remove isComplete Blocking
**File**: `dashboard/src/pages/TimelinePage.tsx`

Remove lines 171-173:
```typescript
if (selectedThread.isComplete) {
    setThreadLoading(false);
    return;
}
```

This allows threads to be refetched each time they're clicked.

#### 6. Remove isComplete Field
**File**: `dashboard/src/components/timeline/TimelineEntryList.tsx`

Remove `isComplete?: boolean` from `SlackThreadEntry` interface.

**File**: `dashboard/src/pages/TimelinePage.tsx`

Remove all references to `isComplete`:
- Line 137: `setThreadLoading(!entry.isComplete);`
- Line 147: `if (selectedThread.isComplete)`
- Line 205: `isComplete: true,`
- Line 566: `!thread.isComplete &&`

## Technical Details

**Thread File Format**:
- Path: `slack_mirror/threads/{CHANNEL}_{TS_UNDERSCORES}.jsonl`
- Example: `C09AMJCQYGG_1763304572_920929.jsonl`
- Format: One JSON message per line (JSONL)

**Environment Variable**:
- Primary: `VIBEOS_SLACK_TOKEN`
- Legacy: `SLACK_TOKEN`
- Read via existing `vibeos_cli::config` helpers

## Testing
1. Click thread that's already mirrored → should load from mirror (fast)
2. Click thread not in mirror with token set → should fetch from API, save, return data
3. Click thread not in mirror without token → should show helpful error
4. Check backend logs for fetch activity
5. Verify thread file appears in mirror after fetch

